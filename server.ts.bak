import express from "express";
import { v4 as uuidv4 } from "uuid";
import axios from "axios";
import WebSocket from "ws";
import bodyParser from "body-parser";
import cors from "cors";

export const app = express();
app.use(cors);
app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json());

const PORT = 3000;

const randUserID = uuidv4();
const randThreadID = uuidv4();

app.post("/query", async (req, res) => {
  console.log(req.body);
  const { input } = req.body;

  if (!input || input.trim().length < 1) {
    return res.status(400).send({ error: "Input cannot be empty" });
  }

  try {
    const stream = await newRequest(input.trim());
    res.writeHead(200, {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      Connection: "keep-alive",
    });

    stream.on("data", (chunk: any) => {
      res.write(chunk);
    });

    stream.on("end", () => {
      res.end();
    });
  } catch (error) {
    console.error("Error:", error);
    return res.status(500).send({ error: "Internal server error" });
  }
});

const wss = new WebSocket.Server({ noServer: true, path: "/ws" });

const parse = (string: string) => {
  try {
    // return JSON.parse(string);
    return;
  } catch (error) {
    return string;
  }
};

const getMessages = async (threadID: string, userID: string) => {
  const options = {
    headers: {
      "Content-Type": "application/json",
      Cookie: `opengpts_user_id=${userID}`,
    },
  };

  try {
    const res = await axios.get(
      `https://opengpts-example-vz4y4ooboq-uc.a.run.app/threads/${threadID}/messages`,
      options
    );
    // console.log(res.data);
  } catch (error) {
    console.error(error);
  }
};

// Start the server
export const server = app.listen(PORT, () =>
  console.log(`Server started on port ${PORT}`)
);

server.on("upgrade", (request, socket, head) => {
  wss.handleUpgrade(request, socket, head, (websocket) => {
    wss.emit("connection", websocket, request);
  });
});

wss.on("connection", (ws, req) => {
  console.log("client connected");

  ws.on("message", async (message: any) => {
    console.log(JSON.parse(message));
    let input;

    try {
      const parsedMessage = JSON.parse(message.toString());
      input = parsedMessage.input;
    } catch (e) {
      ws.send(JSON.stringify({ error: "Invalid JSON" }));
      return;
    }

    if (!input || input.trim().length < 1) {
      ws.send(JSON.stringify({ error: "Input cannot be empty" }));
      return;
    }

    try {
      const stream = await newRequest(input.trim());

      stream.on("data", (chunk: any) => {
        const lines = chunk.toString().split("\r\n");
        const dataLine = lines.find((line: string) =>
          line.startsWith("data: ")
        );

        if (dataLine) {
          const data = dataLine.replace("data: ", "");

          const parsed = parse(data);
          console.log(parsed);

          if (!parsed) return;

          const lastMsg = parsed[parsed.length - 1];

          if (!lastMsg) return;

          // const content = lastMsg.content;
          const content = "sdf";
          if (!content) return;

          try {
            const msg = {
              type: "data",
              message: content,
            };

            ws.send(JSON.stringify(msg));
          } catch (error) {
            console.error("Error parsing JSON:", error);
          }
        }
      });

      stream.on("end", () => {
        ws.send(JSON.stringify({ message: "Stream ended." }));
        ws.close();
        getMessages(randThreadID, randUserID);
      });
    } catch (error) {
      console.error("Error:", error);
      ws.send(JSON.stringify({ error: "Internal server error" }));
    }
  });
});

interface InputData {
  content: string;
  additional_kwargs: any;
  type: string;
  example: boolean;
}

interface RequestBody {
  input: InputData[];
  assistant_id: string;
  thread_id: string;
}

async function newRequest(input: string, threadID: string = randThreadID) {
  const postData: RequestBody = {
    input: [
      {
        content: input,
        additional_kwargs: {},
        type: "human",
        example: false,
      },
    ],
    assistant_id: "9b7706e1-2c59-42c2-ac85-d1b7d0ad4439",
    thread_id: threadID,
  };

  const options = {
    headers: {
      "Content-Type": "application/json",
      Cookie: `opengpts_user_id=${randUserID}`,
      Accept: "text/event-stream",
      "Accept-Language": "en-US,en;q=0.7",
      "Cache-Control": "no-cache",
      Origin: "https://opengpts-example-vz4y4ooboq-uc.a.run.app",
      Pragma: "no-cache",
      Referer: "https://opengpts-example-vz4y4ooboq-uc.a.run.app/",
      "Sec-Fetch-Site": "same-origin",
      "Sec-GPC": "1",
      "User-Agent":
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    },
  };

  try {
    const res = await axios.post(
      "https://opengpts-example-vz4y4ooboq-uc.a.run.app/runs/stream",
      postData,
      { ...options, responseType: "stream" }
    );

    res.data.on("data", (chunk: any) => {
      // Output the data chunk to the console in real-time
      // process.stdout.write(chunk.toString());
    });

    res.data.on("end", () => {
      // console.log("Stream ended.");
    });

    return res.data;
  } catch (error) {
    throw error;
  }
}

function parseAndOutputEventStream(response: string, input: string): void {
  const events = response.split("\r\n\r\n");

  let interval = 200; // milliseconds

  const eventsArr = [];

  for (const event of events) {
    const eventData = event.split("\r\n");
    const eventType = eventData[0]?.replace("event: ", "");
    const eventDataString = eventData[1]?.replace("data: ", "");

    if (eventType === "data" && eventDataString) {
      const eventDataJSON = JSON.parse(eventDataString);

      eventsArr.push(eventDataJSON);

      eventsArr.forEach((data: any) => {
        const phrase = data.content;
        setTimeout(() => {
          process.stdout.clearLine(0);
          process.stdout.cursorTo(0);
          process.stdout.write(phrase);
        }, interval);
        interval += 100;
      });
    }
  }
}
